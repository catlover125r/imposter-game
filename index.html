<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Hub - Play Free Games Online</title>
    <meta name="description" content="Play free online games with friends. Imposter party game, Brasket Handom basketball, and more!">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0a;
            min-height: 100vh;
            color: #e0e0e0;
            overflow-x: hidden;
        }

        /* Scanline overlay */
        body::after {
            content: '';
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0,0,0,0.08) 2px,
                rgba(0,0,0,0.08) 4px
            );
            pointer-events: none;
            z-index: 9999;
        }

        h1, h2, h3, .retro-font {
            font-family: 'Press Start 2P', monospace;
        }

        /* Ad containers */
        .ad-wrapper {
            position: fixed;
            top: 50%;
            transform: translateY(-50%);
            width: 160px;
            min-height: 600px;
            z-index: 50;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .ad-left { left: 10px; }
        .ad-right { right: 10px; }
        @media (max-width: 1200px) {
            .ad-wrapper { display: none; }
        }

        .container {
            text-align: center;
            padding: 20px;
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .screen { display: none; flex-direction: column; align-items: center; gap: 20px; width: 100%; }
        .screen.active { display: flex; }

        /* Buttons */
        .btn {
            padding: 14px 36px;
            font-size: 1rem;
            border: 2px solid;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Press Start 2P', monospace;
            font-size: 0.7rem;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 1px;
            min-width: 180px;
            background: transparent;
        }
        .btn:hover { transform: scale(1.05); }
        .btn:disabled { opacity: 0.4; cursor: not-allowed; transform: none; }

        .btn-green {
            color: #00ff41;
            border-color: #00ff41;
            text-shadow: 0 0 10px rgba(0,255,65,0.5);
            box-shadow: 0 0 15px rgba(0,255,65,0.15), inset 0 0 15px rgba(0,255,65,0.05);
        }
        .btn-green:hover {
            background: #00ff41;
            color: #0a0a0a;
            box-shadow: 0 0 30px rgba(0,255,65,0.4);
        }

        .btn-pink {
            color: #ff0066;
            border-color: #ff0066;
            text-shadow: 0 0 10px rgba(255,0,102,0.5);
            box-shadow: 0 0 15px rgba(255,0,102,0.15), inset 0 0 15px rgba(255,0,102,0.05);
        }
        .btn-pink:hover {
            background: #ff0066;
            color: #0a0a0a;
            box-shadow: 0 0 30px rgba(255,0,102,0.4);
        }

        .btn-cyan {
            color: #00d4ff;
            border-color: #00d4ff;
            text-shadow: 0 0 10px rgba(0,212,255,0.5);
            box-shadow: 0 0 15px rgba(0,212,255,0.15), inset 0 0 15px rgba(0,212,255,0.05);
        }
        .btn-cyan:hover {
            background: #00d4ff;
            color: #0a0a0a;
            box-shadow: 0 0 30px rgba(0,212,255,0.4);
        }

        .btn-small { padding: 8px 18px; font-size: 0.55rem; min-width: auto; }

        /* Back button */
        .back-btn {
            position: fixed;
            top: 20px;
            left: 20px;
            background: transparent;
            border: 2px solid #ff0066;
            color: #ff0066;
            width: 44px;
            height: 44px;
            border-radius: 4px;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s;
            z-index: 100;
            font-family: monospace;
            display: none;
        }
        .back-btn:hover { background: #ff0066; color: #0a0a0a; }

        /* Inputs */
        input[type="text"], input[type="number"] {
            width: 100%;
            max-width: 300px;
            padding: 14px;
            font-size: 1rem;
            font-family: 'Courier New', monospace;
            border: 2px solid #00d4ff;
            border-radius: 4px;
            background: rgba(0,212,255,0.05);
            color: #00d4ff;
            text-align: center;
        }
        input::placeholder { color: rgba(0,212,255,0.4); }
        input:focus { outline: none; box-shadow: 0 0 20px rgba(0,212,255,0.3); }

        /* Game cards */
        .game-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 24px;
            width: 100%;
            max-width: 700px;
            margin: 30px 0;
        }
        .game-card {
            background: rgba(255,255,255,0.02);
            border: 2px solid #222;
            border-radius: 4px;
            padding: 30px 20px;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }
        .game-card::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0;
            height: 3px;
            transition: all 0.3s;
        }
        .game-card:hover {
            transform: translateY(-4px);
            border-color: #444;
        }
        .game-card.imposter-card::before { background: #ff0066; }
        .game-card.imposter-card:hover { border-color: #ff0066; box-shadow: 0 0 30px rgba(255,0,102,0.15); }
        .game-card.brasket-card::before { background: #ff8800; }
        .game-card.brasket-card:hover { border-color: #ff8800; box-shadow: 0 0 30px rgba(255,136,0,0.15); }

        .game-card .card-icon { font-size: 3rem; margin-bottom: 15px; }
        .game-card h2 { font-size: 0.9rem; margin-bottom: 10px; }
        .game-card p { color: #666; font-size: 0.85rem; line-height: 1.5; }

        /* Mode buttons */
        .mode-buttons { display: flex; flex-direction: column; gap: 16px; margin: 20px 0; width: 100%; max-width: 350px; }
        .mode-btn {
            padding: 24px;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            font-family: 'Press Start 2P', monospace;
            font-size: 0.65rem;
            cursor: pointer;
            transition: all 0.2s;
            background: transparent;
        }
        .mode-btn .icon { font-size: 2rem; margin-bottom: 5px; }
        .mode-btn .subtitle { font-size: 0.5rem; opacity: 0.6; font-family: 'Courier New', monospace; }

        /* Side select buttons */
        .side-select { display: flex; gap: 16px; margin: 10px 0; }
        .side-btn {
            padding: 16px 30px;
            border: 2px solid #333;
            border-radius: 4px;
            background: transparent;
            color: #888;
            font-family: 'Press Start 2P', monospace;
            font-size: 0.6rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .side-btn.selected { border-color: #ff8800; color: #ff8800; box-shadow: 0 0 15px rgba(255,136,0,0.2); }
        .side-btn:hover { border-color: #666; color: #ccc; }

        /* Room code display */
        .room-code {
            background: rgba(0,255,65,0.05);
            border: 2px solid #00ff41;
            padding: 16px 32px;
            border-radius: 4px;
            font-family: 'Press Start 2P', monospace;
            font-size: 1.8rem;
            letter-spacing: 8px;
            color: #00ff41;
            text-shadow: 0 0 20px rgba(0,255,65,0.5);
        }

        /* Player list */
        .player-list {
            width: 100%;
            max-width: 350px;
            border: 1px solid #222;
            border-radius: 4px;
            padding: 16px;
            margin: 10px 0;
        }
        .player-list h3 { color: #00d4ff; font-size: 0.6rem; margin-bottom: 12px; }
        .player-item {
            padding: 10px 12px;
            margin: 6px 0;
            background: rgba(255,255,255,0.02);
            border: 1px solid #1a1a1a;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
        }
        .player-item.host::before { content: '>>'; color: #ff8800; margin-right: 4px; font-weight: bold; }
        .player-item.you { border-color: #00ff41; }

        /* Voting UI */
        .vote-player-item {
            padding: 10px 12px;
            margin: 6px 0;
            background: rgba(255,255,255,0.02);
            border: 1px solid #1a1a1a;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }
        .vote-player-item.you { border-color: #00ff41; }
        .vote-player-info { display: flex; align-items: center; gap: 8px; flex: 1; }
        .vote-player-name { font-weight: bold; }
        .vote-count {
            background: #ff0066;
            color: #0a0a0a;
            padding: 2px 8px;
            border-radius: 2px;
            font-size: 0.85rem;
            min-width: 24px;
            text-align: center;
            font-weight: bold;
        }
        .vote-btn {
            padding: 6px 14px;
            font-size: 0.5rem;
            font-family: 'Press Start 2P', monospace;
            background: transparent;
            border: 1px solid #ff0066;
            color: #ff0066;
            border-radius: 2px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .vote-btn:hover:not(:disabled) { background: #ff0066; color: #0a0a0a; }
        .vote-btn:disabled { opacity: 0.4; cursor: not-allowed; }
        .vote-btn.voted { background: #00ff41; border-color: #00ff41; color: #0a0a0a; }
        .your-vote-label { color: #00ff41; font-size: 0.75rem; margin-left: 4px; }

        /* Role card */
        .role-card {
            border: 2px solid #333;
            border-radius: 4px;
            padding: 30px;
            margin: 15px 0;
            min-width: 260px;
            background: rgba(255,255,255,0.02);
        }
        .role-card.imposter { border-color: #ff0066; box-shadow: 0 0 30px rgba(255,0,102,0.2); }
        .role-card.crewmate { border-color: #00ff41; box-shadow: 0 0 30px rgba(0,255,65,0.2); }
        .role-label { font-size: 0.9rem; color: #666; margin-bottom: 8px; }
        .role-text { font-size: 1.4rem; font-weight: bold; font-family: 'Press Start 2P', monospace; }
        .role-card.imposter .role-text { color: #ff0066; text-shadow: 0 0 20px rgba(255,0,102,0.5); }
        .role-card.crewmate .role-text { color: #00ff41; text-shadow: 0 0 20px rgba(0,255,65,0.5); }

        /* Result card */
        .result-card {
            border: 2px solid #333;
            border-radius: 4px;
            padding: 24px;
            margin: 15px 0;
            min-width: 260px;
            background: rgba(255,255,255,0.02);
        }
        .result-card.caught { border-color: #00ff41; box-shadow: 0 0 30px rgba(0,255,65,0.2); }
        .result-card.escaped { border-color: #ff0066; box-shadow: 0 0 30px rgba(255,0,102,0.2); }
        .result-label { font-size: 0.85rem; color: #666; margin-bottom: 8px; }
        .result-name { font-size: 1.2rem; font-weight: bold; color: #ff0066; margin-bottom: 8px; font-family: 'Press Start 2P', monospace; }
        .result-word { font-size: 1rem; color: #00ff41; margin-bottom: 12px; }
        .result-message { font-size: 0.9rem; font-weight: bold; }
        .result-card.caught .result-message { color: #00ff41; }
        .result-card.escaped .result-message { color: #ff0066; }

        /* Word editor */
        .word-editor-section { width: 100%; max-width: 400px; margin-top: 16px; padding-top: 16px; border-top: 1px solid #1a1a1a; }
        .word-textarea {
            width: 100%;
            height: 120px;
            background: rgba(0,212,255,0.03);
            border: 1px solid #222;
            border-radius: 4px;
            color: #00d4ff;
            font-size: 0.9rem;
            padding: 12px;
            resize: vertical;
            font-family: 'Courier New', monospace;
        }
        .word-textarea::placeholder { color: #333; }
        .word-textarea:focus { outline: none; border-color: #00d4ff; }
        .word-count { margin-top: 6px; color: #444; font-size: 0.8rem; }

        /* Player boxes (single device imposter) */
        .player-boxes { display: flex; flex-wrap: wrap; justify-content: center; gap: 12px; margin-top: 20px; }
        .player-box {
            width: 80px;
            height: 80px;
            border: 2px solid #ff0066;
            border-radius: 4px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Press Start 2P', monospace;
            font-size: 0.6rem;
            color: #ff0066;
            cursor: pointer;
            transition: all 0.3s;
            background: transparent;
        }
        .player-box:hover:not(.revealed) { box-shadow: 0 0 20px rgba(255,0,102,0.4); transform: scale(1.05); }
        .player-box.revealed { border-color: #222; color: #333; cursor: default; }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background: #0a0a0a;
            border: 2px solid #ff0066;
            padding: 40px;
            border-radius: 4px;
            text-align: center;
            max-width: 90%;
        }
        .modal .role-text { font-size: 1.4rem; margin-bottom: 24px; }

        /* Status text */
        .status { color: #444; font-size: 0.9rem; margin: 8px 0; }
        .status.waiting { animation: blink 1.5s step-end infinite; }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
        .error { color: #ff0066; font-size: 0.9rem; margin: 8px 0; }
        .or-text { color: #333; margin: 8px 0; font-family: 'Press Start 2P', monospace; font-size: 0.5rem; }

        /* Misc */
        .instructions { color: #444; font-size: 0.8rem; margin-top: 8px; line-height: 1.6; }
        .vote-instruction { color: #444; font-size: 0.8rem; margin-bottom: 8px; }
        .button-row { display: flex; gap: 12px; flex-wrap: wrap; justify-content: center; }
        .end-buttons { display: none; margin-top: 20px; gap: 12px; justify-content: center; flex-wrap: wrap; }

        /* Game canvas container */
        .game-canvas-wrap {
            width: 100%;
            max-width: 800px;
            aspect-ratio: 8/5;
            border: 2px solid #ff8800;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
            background: #1a0a00;
        }
        .game-canvas-wrap canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Iframe game container */
        .iframe-wrap {
            width: 100%;
            max-width: 900px;
            aspect-ratio: 4/3;
            border: 2px solid #ff8800;
            border-radius: 4px;
            overflow: hidden;
        }
        .iframe-wrap iframe { width: 100%; height: 100%; border: none; }

        /* Control hints */
        .control-hints {
            display: flex;
            gap: 30px;
            justify-content: center;
            margin: 10px 0;
        }
        .control-hint {
            font-size: 0.8rem;
            color: #666;
        }
        .control-hint kbd {
            background: #1a1a1a;
            border: 1px solid #333;
            padding: 2px 8px;
            border-radius: 3px;
            color: #ff8800;
            font-family: 'Press Start 2P', monospace;
            font-size: 0.5rem;
        }

        /* Footer */
        .footer {
            margin-top: 40px;
            padding-top: 16px;
            border-top: 1px solid #111;
        }
        .footer a { color: #333; text-decoration: none; font-size: 0.75rem; transition: color 0.2s; }
        .footer a:hover { color: #666; }

        /* Title glow */
        .title-glow {
            font-size: 1.5rem;
            color: #00ff41;
            text-shadow: 0 0 30px rgba(0,255,65,0.4), 0 0 60px rgba(0,255,65,0.1);
            margin-bottom: 8px;
        }
        .subtitle { color: #444; font-size: 0.5rem; font-family: 'Press Start 2P', monospace; letter-spacing: 3px; }

        /* Score display for brasket */
        .score-display {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 24px;
            font-family: 'Press Start 2P', monospace;
            margin: 10px 0;
        }
        .score-left { color: #00d4ff; font-size: 1.5rem; text-shadow: 0 0 15px rgba(0,212,255,0.5); }
        .score-sep { color: #333; font-size: 1rem; }
        .score-right { color: #ff8800; font-size: 1.5rem; text-shadow: 0 0 15px rgba(255,136,0,0.5); }

        /* Modifier announcement */
        .modifier-announce {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Press Start 2P', monospace;
            font-size: 1rem;
            color: #fff;
            text-shadow: 0 0 20px rgba(255,255,255,0.8);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 10;
        }
        .modifier-announce.show { opacity: 1; }

        @media (max-width: 600px) {
            .title-glow { font-size: 1rem; }
            .game-grid { grid-template-columns: 1fr; }
            .game-card h2 { font-size: 0.7rem; }
            .btn { font-size: 0.55rem; padding: 12px 24px; min-width: 150px; }
            .room-code { font-size: 1.3rem; padding: 12px 20px; }
        }
    </style>
</head>
<body>
    <!-- Google AdSense -->
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1190255474469820" crossorigin="anonymous"></script>

    <!-- Left Ad -->
    <div class="ad-wrapper ad-left">
        <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-1190255474469820" data-ad-slot="5870859418" data-ad-format="vertical" data-full-width-responsive="false"></ins>
        <script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
    </div>

    <!-- Right Ad -->
    <div class="ad-wrapper ad-right">
        <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-1190255474469820" data-ad-slot="5870859418" data-ad-format="vertical" data-full-width-responsive="false"></ins>
        <script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
    </div>

    <div class="container">

        <!-- ========== LANDING PAGE ========== -->
        <div class="screen active" id="landingScreen">
            <h1 class="title-glow">GAME HUB</h1>
            <p class="subtitle">SELECT A GAME</p>

            <div class="game-grid">
                <div class="game-card imposter-card" onclick="showScreen('impModeScreen')">
                    <div class="card-icon">?!</div>
                    <h2 style="color:#ff0066">IMPOSTER</h2>
                    <p>Social deduction party game. One player is the imposter &mdash; can your group find them?</p>
                </div>
                <div class="game-card brasket-card" onclick="showScreen('brModeScreen')">
                    <div class="card-icon">//</div>
                    <h2 style="color:#ff8800">BRASKET HANDOM</h2>
                    <p>Chaotic basketball with random physics. Play on one device or online with a friend!</p>
                </div>
            </div>

            <div class="footer">
                <a href="#" onclick="showScreen('privacyScreen'); return false;">Privacy Policy</a>
            </div>
        </div>

        <!-- ========== PRIVACY (minimal) ========== -->
        <div class="screen" id="privacyScreen">
            <button class="back-btn" onclick="showScreen('landingScreen')">&#8592;</button>
            <h2 style="color:#666; font-size:0.7rem;">Privacy Policy</h2>
            <div style="max-width:500px; text-align:left; color:#555; font-size:0.8rem; line-height:1.7; margin-top:16px;">
                <p>We collect no personal data. Display names and game data are temporary and deleted when you leave. We use Google Firebase for multiplayer and Google AdSense for ads. See <a href="https://policies.google.com/privacy" style="color:#00d4ff;" target="_blank">Google's Privacy Policy</a> for details.</p>
                <p style="margin-top:12px;">Contact: <span style="color:#00d4ff;">contact@secretimposter.com</span></p>
            </div>
        </div>

        <!-- ========== IMPOSTER: MODE SELECT ========== -->
        <div class="screen" id="impModeScreen">
            <button class="back-btn" onclick="showScreen('landingScreen')">&#8592;</button>
            <h1 style="color:#ff0066; font-size:1.2rem;">IMPOSTER</h1>
            <p style="color:#444; font-size:0.8rem;">Choose your game mode</p>
            <div class="mode-buttons">
                <button class="btn btn-pink mode-btn" onclick="selectImpMode('single')">
                    <span class="icon">1</span><span>One Device</span><span class="subtitle">Pass the phone around</span>
                </button>
                <button class="btn btn-green mode-btn" onclick="selectImpMode('multi')">
                    <span class="icon">+++</span><span>Multiple Devices</span><span class="subtitle">Everyone on their own phone</span>
                </button>
            </div>
        </div>

        <!-- IMPOSTER: Single device lobby -->
        <div class="screen" id="singleLobbyScreen">
            <button class="back-btn" onclick="showScreen('impModeScreen')">&#8592;</button>
            <h1 style="color:#ff0066; font-size:1rem;">ONE DEVICE</h1>
            <div style="display:flex; flex-direction:column; align-items:center; gap:12px;">
                <label style="font-size:0.9rem; color:#888;">Number of Players:</label>
                <input type="number" id="singlePlayerCount" min="3" max="20" value="4" style="width:80px; height:50px; font-size:1.5rem;">
            </div>
            <button class="btn btn-pink" onclick="startSingleGame()">PLAY</button>
            <button class="btn btn-cyan btn-small" onclick="toggleSingleWordEditor()" id="singleEditBtn">EDIT WORDS</button>
            <div class="word-editor-section" id="singleWordEditorSection" style="display:none;">
                <p style="color:#444; font-size:0.8rem; margin-bottom:8px;">One word per line or comma-separated</p>
                <textarea class="word-textarea" id="singleWordTextarea" placeholder="Enter words..."></textarea>
                <div class="word-count" id="singleWordCount">0 words</div>
                <div class="button-row" style="margin-top:8px;">
                    <button class="btn btn-cyan btn-small" onclick="resetWordsSingle()">RESET</button>
                    <button class="btn btn-green btn-small" onclick="toggleSingleWordEditor()">DONE</button>
                </div>
            </div>
            <p class="instructions">Each player taps a box to see their role. One person is the IMPOSTER!</p>
        </div>

        <!-- IMPOSTER: Single device game -->
        <div class="screen" id="singleGameScreen">
            <h2 style="color:#ff0066; font-size:0.8rem;">TAP YOUR BOX</h2>
            <div class="player-boxes" id="singlePlayerBoxes"></div>
            <div class="end-buttons" id="singleEndButtons">
                <button class="btn btn-cyan" onclick="newSingleRound()">NEW ROUND</button>
                <button class="btn btn-pink" onclick="showScreen('singleLobbyScreen')">LOBBY</button>
            </div>
        </div>

        <div class="modal" id="singleModal">
            <div class="modal-content">
                <div class="role-text" id="singleRoleText"></div>
                <button class="btn btn-green" onclick="closeSingleModal()">OK</button>
            </div>
        </div>

        <!-- IMPOSTER: Multi menu -->
        <div class="screen" id="multiMenuScreen">
            <button class="back-btn" onclick="showScreen('impModeScreen')">&#8592;</button>
            <h1 style="color:#ff0066; font-size:1rem;">MULTIPLAYER</h1>
            <input type="text" id="playerName" placeholder="Your name" maxlength="15">
            <button class="btn btn-pink" onclick="createRoom()">CREATE ROOM</button>
            <div class="or-text">-- or --</div>
            <input type="text" id="joinCode" placeholder="Room code" maxlength="6" style="text-transform:uppercase;">
            <button class="btn btn-green" onclick="joinRoom()">JOIN ROOM</button>
            <p class="error" id="menuError"></p>
        </div>

        <!-- IMPOSTER: Multi lobby -->
        <div class="screen" id="multiLobbyScreen">
            <h2 style="color:#ff0066; font-size:0.8rem;">LOBBY</h2>
            <p style="color:#666; font-size:0.8rem;">Room Code:</p>
            <div class="room-code" id="displayRoomCode">----</div>
            <div class="player-list"><h3>Players</h3><div id="playerListContainer"></div></div>
            <button class="btn btn-pink" id="startGameBtn" onclick="startMultiGame()" style="display:none;">START GAME</button>
            <p class="status waiting" id="lobbyStatus">Waiting for host...</p>
            <button class="btn btn-cyan btn-small" onclick="toggleMultiWordEditor()" id="multiEditBtn">EDIT WORDS</button>
            <div class="word-editor-section" id="multiWordEditorSection" style="display:none;">
                <p style="color:#444; font-size:0.8rem; margin-bottom:8px;">One word per line or comma-separated</p>
                <textarea class="word-textarea" id="multiWordTextarea" placeholder="Enter words..."></textarea>
                <div class="word-count" id="multiWordCount">0 words</div>
                <div class="button-row" style="margin-top:8px;">
                    <button class="btn btn-cyan btn-small" onclick="resetWordsMulti()">RESET</button>
                    <button class="btn btn-green btn-small" onclick="saveWordsMulti()">SAVE</button>
                </div>
            </div>
            <button class="btn btn-pink btn-small" onclick="leaveRoom()" style="margin-top:16px;">LEAVE</button>
        </div>

        <!-- IMPOSTER: Multi game -->
        <div class="screen" id="multiGameScreen">
            <h2 id="roleTitle" style="color:#ff0066; font-size:0.8rem;">YOUR ROLE</h2>
            <div class="role-card" id="roleCard">
                <div class="role-label" id="roleLabel">You are:</div>
                <div class="role-text" id="multiRoleText">Loading...</div>
            </div>
            <p class="vote-instruction">Vote for who you think is the imposter!</p>
            <div class="player-list"><h3>VOTE</h3><div id="votePlayerList"></div></div>
            <p class="status" id="voteStatus">Waiting for votes...</p>
        </div>

        <!-- IMPOSTER: Multi end -->
        <div class="screen" id="multiEndScreen">
            <h2 style="color:#ff0066; font-size:0.8rem;">RESULTS</h2>
            <div class="result-card" id="resultCard">
                <div class="result-label">The imposter was:</div>
                <div class="result-name" id="resultName">???</div>
                <div class="result-word" id="resultWord"></div>
                <div class="result-message" id="resultMessage">???</div>
            </div>
            <div class="player-list"><h3>Final Votes</h3><div id="endPlayerList"></div></div>
            <button class="btn btn-cyan" id="newRoundBtn" onclick="newMultiRound()" style="display:none;">NEW ROUND</button>
            <button class="btn btn-pink" id="backToLobbyBtn" onclick="backToMultiLobby()" style="display:none;">LOBBY</button>
            <button class="btn btn-pink btn-small" id="leaveRoomEndBtn" onclick="leaveRoom()" style="display:none;">LEAVE</button>
            <p class="status waiting" id="endStatus">Waiting for host...</p>
        </div>

        <!-- ========== BRASKET HANDOM: MODE SELECT ========== -->
        <div class="screen" id="brModeScreen">
            <button class="back-btn" onclick="showScreen('landingScreen')">&#8592;</button>
            <h1 style="color:#ff8800; font-size:1rem;">BRASKET HANDOM</h1>
            <p style="color:#444; font-size:0.8rem;">How do you want to play?</p>
            <div class="mode-buttons">
                <button class="btn btn-cyan mode-btn" style="border-color:#ff8800; color:#ff8800;" onclick="showScreen('brLocalSetup')">
                    <span class="icon">1</span><span>On Device</span><span class="subtitle">Play on this device</span>
                </button>
                <button class="btn btn-green mode-btn" style="border-color:#ff8800; color:#ff8800;" onclick="showScreen('brOnlineMenu')">
                    <span class="icon">@</span><span>Online</span><span class="subtitle">Play with a friend remotely</span>
                </button>
            </div>
        </div>

        <!-- BRASKET: Local setup -->
        <div class="screen" id="brLocalSetup">
            <button class="back-btn" onclick="showScreen('brModeScreen')">&#8592;</button>
            <h2 style="color:#ff8800; font-size:0.8rem;">ON DEVICE</h2>

            <p style="color:#888; font-size:0.8rem;">Players:</p>
            <div class="side-select" id="brPlayerCountSelect">
                <button class="side-btn selected" onclick="brSetPlayerCount(1)" id="br1PBtn">1 PLAYER</button>
                <button class="side-btn" onclick="brSetPlayerCount(2)" id="br2PBtn">2 PLAYERS</button>
            </div>

            <p style="color:#888; font-size:0.8rem;" id="brSideLabel">Your side:</p>
            <div class="side-select" id="brSideSelect">
                <button class="side-btn selected" onclick="brSetSide('left')" id="brLeftBtn">LEFT</button>
                <button class="side-btn" onclick="brSetSide('right')" id="brRightBtn">RIGHT</button>
            </div>

            <button class="btn btn-green" style="border-color:#ff8800; color:#ff8800; margin-top:10px;" onclick="startBrLocal()">START</button>

            <div class="control-hints" style="margin-top:16px;">
                <span class="control-hint">Left: <kbd>W</kbd></span>
                <span class="control-hint">Right: <kbd>UP</kbd></span>
            </div>
        </div>

        <!-- BRASKET: Local game -->
        <div class="screen" id="brLocalGame">
            <button class="back-btn" onclick="exitBrLocal()">&#8592;</button>
            <div class="iframe-wrap" id="brIframeWrap">
                <iframe id="brIframe" src="" allowfullscreen></iframe>
            </div>
            <div class="control-hints">
                <span class="control-hint">Left player: <kbd>W</kbd></span>
                <span class="control-hint">Right player: <kbd>UP</kbd></span>
            </div>
            <button class="btn btn-pink btn-small" onclick="exitBrLocal()" style="margin-top:8px;">EXIT</button>
        </div>

        <!-- BRASKET: Online menu -->
        <div class="screen" id="brOnlineMenu">
            <button class="back-btn" onclick="showScreen('brModeScreen')">&#8592;</button>
            <h2 style="color:#ff8800; font-size:0.8rem;">ONLINE</h2>

            <input type="text" id="brPlayerName" placeholder="Your name" maxlength="15" style="border-color:#ff8800; color:#ff8800; background:rgba(255,136,0,0.05);">

            <button class="btn btn-green" style="border-color:#ff8800; color:#ff8800;" onclick="brCreateRoom()">CREATE ROOM</button>
            <div class="or-text">-- or --</div>
            <input type="text" id="brJoinCode" placeholder="Room code" maxlength="6" style="text-transform:uppercase; border-color:#ff8800; color:#ff8800; background:rgba(255,136,0,0.05);">
            <button class="btn btn-cyan" style="border-color:#ff8800; color:#ff8800;" onclick="brJoinRoom()">JOIN ROOM</button>

            <p style="color:#888; font-size:0.8rem; margin-top:12px;">Your side:</p>
            <div class="side-select">
                <button class="side-btn selected" onclick="brOnlineSetSide('left')" id="brOnLeftBtn">LEFT</button>
                <button class="side-btn" onclick="brOnlineSetSide('right')" id="brOnRightBtn">RIGHT</button>
            </div>

            <p class="error" id="brMenuError"></p>
        </div>

        <!-- BRASKET: Online lobby -->
        <div class="screen" id="brOnlineLobby">
            <h2 style="color:#ff8800; font-size:0.8rem;">LOBBY</h2>
            <p style="color:#666; font-size:0.8rem;">Room Code:</p>
            <div class="room-code" style="border-color:#ff8800; color:#ff8800; background:rgba(255,136,0,0.05); text-shadow:0 0 20px rgba(255,136,0,0.5);" id="brDisplayRoomCode">----</div>
            <div class="player-list" id="brPlayerListWrap">
                <h3 style="color:#ff8800;">Players</h3>
                <div id="brPlayerListContainer"></div>
            </div>
            <button class="btn btn-green" style="border-color:#ff8800; color:#ff8800;" id="brStartBtn" onclick="brStartOnlineGame()" style="display:none;">START</button>
            <p class="status waiting" id="brLobbyStatus">Waiting for opponent...</p>
            <button class="btn btn-pink btn-small" onclick="brLeaveRoom()">LEAVE</button>
        </div>

        <!-- BRASKET: Online game -->
        <div class="screen" id="brOnlineGame">
            <div class="score-display">
                <span class="score-left" id="brScoreLeft">0</span>
                <span class="score-sep">:</span>
                <span class="score-right" id="brScoreRight">0</span>
            </div>
            <div class="game-canvas-wrap" id="brCanvasWrap">
                <canvas id="brCanvas" width="800" height="500"></canvas>
                <div class="modifier-announce" id="brModAnnounce"></div>
            </div>
            <p style="color:#444; font-size:0.7rem; margin-top:6px;">Press <kbd style="background:#1a1a1a; border:1px solid #333; padding:1px 6px; border-radius:2px; color:#ff8800; font-family:'Press Start 2P',monospace; font-size:0.4rem;">SPACE</kbd> or <kbd style="background:#1a1a1a; border:1px solid #333; padding:1px 6px; border-radius:2px; color:#ff8800; font-family:'Press Start 2P',monospace; font-size:0.4rem;">W</kbd> or <kbd style="background:#1a1a1a; border:1px solid #333; padding:1px 6px; border-radius:2px; color:#ff8800; font-family:'Press Start 2P',monospace; font-size:0.4rem;">UP</kbd> to jump</p>
            <button class="btn btn-pink btn-small" onclick="brLeaveOnlineGame()" style="margin-top:8px;">LEAVE</button>
        </div>

        <!-- BRASKET: Online game over -->
        <div class="screen" id="brOnlineEnd">
            <h2 style="color:#ff8800; font-size:0.8rem;">GAME OVER</h2>
            <div class="score-display">
                <span class="score-left" id="brEndScoreLeft">0</span>
                <span class="score-sep">:</span>
                <span class="score-right" id="brEndScoreRight">0</span>
            </div>
            <p id="brEndMessage" style="color:#ff8800; font-family:'Press Start 2P',monospace; font-size:0.7rem; margin:16px 0;"></p>
            <button class="btn btn-green" style="border-color:#ff8800; color:#ff8800;" id="brPlayAgainBtn" onclick="brPlayAgain()" style="display:none;">PLAY AGAIN</button>
            <button class="btn btn-pink btn-small" onclick="brLeaveRoom()">LEAVE</button>
            <p class="status waiting" id="brEndStatus" style="display:none;">Waiting for host...</p>
        </div>
    </div>

    <!-- Firebase -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>

    <script>
    // ============================================================
    // FIREBASE INIT
    // ============================================================
    const firebaseConfig = {
        apiKey: "AIzaSyAOsYfd3vBVUzHqysG_oXPKi7yXrI-hVrE",
        authDomain: "imposter-game-777f3.firebaseapp.com",
        databaseURL: "https://imposter-game-777f3-default-rtdb.firebaseio.com",
        projectId: "imposter-game-777f3",
        storageBucket: "imposter-game-777f3.firebasestorage.app",
        messagingSenderId: "791197389028",
        appId: "1:791197389028:web:72282811d5e08040a7dcf1"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    // ============================================================
    // NAVIGATION
    // ============================================================
    let currentScreen = 'landingScreen';

    function showScreen(id) {
        document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
        document.getElementById(id).classList.add('active');
        document.querySelectorAll('.back-btn').forEach(b => b.style.display = 'none');
        const bb = document.getElementById(id).querySelector('.back-btn');
        if (bb) bb.style.display = 'block';
        currentScreen = id;
    }

    // ============================================================
    // IMPOSTER GAME (preserved logic)
    // ============================================================
    const defaultWords = ["Pizza","Coffee","Sushi","Hamburger","Ice cream","Chocolate","Sandwich","Pasta","Cookies","Bacon","Elephant","Dolphin","Penguin","Giraffe","Octopus","Butterfly","Tiger","Kangaroo","Shark","Eagle","Umbrella","Backpack","Sunglasses","Headphones","Flashlight","Wallet","Pillow","Camera","Skateboard","Guitar","Beach","Library","Restaurant","Airport","Stadium","Hospital","Museum","Gym","Theater","Park","Swimming","Dancing","Cooking","Reading","Painting","Camping","Shopping","Singing","Jogging","Gaming","Teacher","Doctor","Chef","Firefighter","Pilot","Artist","Scientist","Musician","Athlete","Photographer"];

    let singleModeWords = [...defaultWords];
    let multiModeWords = [...defaultWords];
    let singleWordQueue = [];
    let multiWordQueue = [];

    function shuffleArray(arr) { const s=[...arr]; for(let i=s.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[s[i],s[j]]=[s[j],s[i]];} return s; }
    function getNextSingleWord() { if(!singleWordQueue.length) singleWordQueue=shuffleArray(singleModeWords); return singleWordQueue.pop(); }
    function getNextMultiWord(wl) { if(!multiWordQueue.length) multiWordQueue=shuffleArray(wl); return multiWordQueue.pop(); }
    function parseWordsFromText(t) { return t.split(/[,\n]+/).map(w=>w.trim()).filter(w=>w.length>0); }
    function wordsToText(a) { return a.join('\n'); }
    function updateSingleWordCount() { const t=document.getElementById('singleWordTextarea'); if(t) document.getElementById('singleWordCount').textContent=parseWordsFromText(t.value).length+' words'; }
    function updateMultiWordCount() { const t=document.getElementById('multiWordTextarea'); if(t) document.getElementById('multiWordCount').textContent=parseWordsFromText(t.value).length+' words'; }

    function updateSingleWords() {
        const t=document.getElementById('singleWordTextarea');
        singleModeWords=parseWordsFromText(t.value);
        if(!singleModeWords.length){singleModeWords=[...defaultWords];t.value=wordsToText(singleModeWords);}
        singleWordQueue=[];
        updateSingleWordCount();
    }
    function resetWordsSingle() { singleModeWords=[...defaultWords]; singleWordQueue=[]; document.getElementById('singleWordTextarea').value=wordsToText(singleModeWords); updateSingleWordCount(); }
    async function saveWordsMulti() {
        const t=document.getElementById('multiWordTextarea');
        multiModeWords=parseWordsFromText(t.value);
        if(!multiModeWords.length){multiModeWords=[...defaultWords];t.value=wordsToText(multiModeWords);}
        multiWordQueue=[];
        updateMultiWordCount();
        if(roomRef) await roomRef.child('words').set(multiModeWords);
    }
    async function resetWordsMulti() { multiModeWords=[...defaultWords]; multiWordQueue=[]; document.getElementById('multiWordTextarea').value=wordsToText(multiModeWords); updateMultiWordCount(); if(roomRef) await roomRef.child('words').set(multiModeWords); }
    function initSingleWordEditor() { singleModeWords=[...defaultWords]; singleWordQueue=[]; const t=document.getElementById('singleWordTextarea'); if(t){t.value=wordsToText(singleModeWords);updateSingleWordCount();} }
    function initMultiWordEditor() { const t=document.getElementById('multiWordTextarea'); if(t){t.value=wordsToText(multiModeWords);updateMultiWordCount();} }
    function toggleSingleWordEditor() { const s=document.getElementById('singleWordEditorSection'); s.style.display=s.style.display==='none'?'block':'none'; }
    function toggleMultiWordEditor() { const s=document.getElementById('multiWordEditorSection'); s.style.display=s.style.display==='none'?'block':'none'; }

    function selectImpMode(mode) { if(mode==='single'){showScreen('singleLobbyScreen');initSingleWordEditor();}else{showScreen('multiMenuScreen');} }

    // Single device game
    let singlePlayerCount=4, singleImposterIndex=0, singleCurrentWord="", singleRevealedCount=0, singleCurrentBoxIndex=-1;

    function startSingleGame() {
        updateSingleWords();
        singlePlayerCount=Math.min(20,Math.max(3,parseInt(document.getElementById('singlePlayerCount').value)));
        setupSingleRound();
        showScreen('singleGameScreen');
    }
    function setupSingleRound() {
        singleImposterIndex=Math.floor(Math.random()*singlePlayerCount);
        singleCurrentWord=getNextSingleWord();
        singleRevealedCount=0;
        const c=document.getElementById('singlePlayerBoxes'); c.innerHTML='';
        for(let i=0;i<singlePlayerCount;i++){
            const b=document.createElement('div'); b.className='player-box'; b.textContent='P'+(i+1);
            b.onclick=()=>revealSingleRole(i); c.appendChild(b);
        }
        document.getElementById('singleEndButtons').style.display='none';
    }
    function revealSingleRole(i) {
        const boxes=document.querySelectorAll('#singlePlayerBoxes .player-box');
        if(boxes[i].classList.contains('revealed')) return;
        singleCurrentBoxIndex=i;
        const rt=document.getElementById('singleRoleText');
        if(i===singleImposterIndex){rt.textContent='IMPOSTER';rt.className='role-text imposter';}
        else{rt.textContent=singleCurrentWord;rt.className='role-text crewmate';}
        document.getElementById('singleModal').style.display='flex';
    }
    function closeSingleModal() {
        document.getElementById('singleModal').style.display='none';
        const boxes=document.querySelectorAll('#singlePlayerBoxes .player-box');
        boxes[singleCurrentBoxIndex].classList.add('revealed'); boxes[singleCurrentBoxIndex].textContent='OK';
        singleRevealedCount++;
        if(singleRevealedCount===singlePlayerCount) document.getElementById('singleEndButtons').style.display='flex';
    }
    function newSingleRound() { setupSingleRound(); }

    // Multiplayer
    let playerId=null, playerName='', roomCode=null, isHost=false, roomRef=null;
    function generatePlayerId() { return 'p_'+Math.random().toString(36).substr(2,9); }
    function generateRoomCode() { const c='ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; let r=''; for(let i=0;i<4;i++) r+=c.charAt(Math.floor(Math.random()*c.length)); return r; }

    async function createRoom() {
        playerName=document.getElementById('playerName').value.trim();
        if(!playerName){document.getElementById('menuError').textContent='Enter your name!';return;}
        playerId=generatePlayerId(); roomCode=generateRoomCode(); isHost=true;
        roomRef=db.ref('rooms/'+roomCode);
        const snap=await roomRef.once('value');
        if(snap.exists()){roomCode=generateRoomCode();roomRef=db.ref('rooms/'+roomCode);}
        multiModeWords=[...defaultWords];
        await roomRef.set({host:playerId,status:'lobby',players:{[playerId]:{name:playerName,isHost:true}},gameData:null,words:multiModeWords,createdAt:firebase.database.ServerValue.TIMESTAMP});
        roomRef.child('players/'+playerId).onDisconnect().remove();
        setupRoomListeners();
        document.getElementById('displayRoomCode').textContent=roomCode;
        document.getElementById('startGameBtn').style.display='block';
        document.getElementById('lobbyStatus').style.display='none';
        initMultiWordEditor();
        showScreen('multiLobbyScreen');
    }

    async function joinRoom() {
        playerName=document.getElementById('playerName').value.trim();
        const code=document.getElementById('joinCode').value.trim().toUpperCase();
        if(!playerName){document.getElementById('menuError').textContent='Enter your name!';return;}
        if(!code||code.length!==4){document.getElementById('menuError').textContent='Enter a valid 4-letter code!';return;}
        roomCode=code; roomRef=db.ref('rooms/'+roomCode);
        const snap=await roomRef.once('value');
        if(!snap.exists()){document.getElementById('menuError').textContent='Room not found!';return;}
        const rd=snap.val();
        if(rd.status!=='lobby'){document.getElementById('menuError').textContent='Game already started!';return;}
        playerId=generatePlayerId(); isHost=false;
        multiModeWords=rd.words||[...defaultWords];
        await roomRef.child('players/'+playerId).set({name:playerName,isHost:false});
        roomRef.child('players/'+playerId).onDisconnect().remove();
        setupRoomListeners();
        document.getElementById('displayRoomCode').textContent=roomCode;
        document.getElementById('startGameBtn').style.display='none';
        document.getElementById('lobbyStatus').style.display='block';
        initMultiWordEditor();
        showScreen('multiLobbyScreen');
    }

    function setupRoomListeners() {
        roomRef.on('value',(snap)=>{
            if(!snap.exists()){alert('Room closed!');showScreen('multiMenuScreen');roomRef=null;return;}
            const data=snap.val();
            if(data.words&&Array.isArray(data.words)){multiModeWords=data.words;const t=document.getElementById('multiWordTextarea');if(t&&currentScreen==='multiLobbyScreen'){t.value=wordsToText(multiModeWords);updateMultiWordCount();}}
            if(data.host===playerId) isHost=true;
            updateLobbyPlayerList(data.players);
            if(data.status==='playing'&&(currentScreen==='multiLobbyScreen'||currentScreen==='multiEndScreen')) showMultiGameScreen(data);
            else if(data.status==='playing'&&currentScreen==='multiGameScreen') updateVotingUI(data);
            else if(data.status==='results'&&currentScreen==='multiGameScreen') showMultiEndScreen(data);
            else if(data.status==='lobby'&&(currentScreen==='multiEndScreen'||currentScreen==='multiGameScreen')) showMultiLobbyFromEnd(data);
            if(currentScreen==='multiEndScreen') updateEndScreenButtons();
        });
    }

    function updateLobbyPlayerList(players) {
        const c=document.getElementById('playerListContainer'); if(!c)return; c.innerHTML='';
        for(const[id,p]of Object.entries(players||{})){
            const d=document.createElement('div'); d.className='player-item';
            if(p.isHost) d.classList.add('host'); if(id===playerId) d.classList.add('you');
            d.textContent=p.name+(id===playerId?' (You)':''); c.appendChild(d);
        }
        const cnt=Object.keys(players||{}).length;
        const btn=document.getElementById('startGameBtn');
        if(btn&&isHost){btn.disabled=cnt<3;btn.textContent=cnt<3?'NEED 3+':'START GAME';}
    }

    async function startMultiGame() {
        if(!isHost)return;
        const snap=await roomRef.once('value');const data=snap.val();
        const pids=Object.keys(data.players);
        if(pids.length<3){alert('Need 3+ players!');return;}
        const impIdx=Math.floor(Math.random()*pids.length);
        const impId=pids[impIdx];
        const gw=data.words||multiModeWords;
        const word=getNextMultiWord(gw);
        const roles={},votes={};
        pids.forEach(id=>{roles[id]={isImposter:id===impId,word:id===impId?null:word};votes[id]=null;});
        await roomRef.update({gameData:{roles,word,imposterId:impId,votes},status:'playing'});
    }

    function showMultiGameScreen(data) {
        const my=data.gameData.roles[playerId];
        const rc=document.getElementById('roleCard'),rt=document.getElementById('multiRoleText');
        const title=document.getElementById('roleTitle'),label=document.getElementById('roleLabel');
        if(my.isImposter){rc.className='role-card imposter';rt.textContent='IMPOSTER';title.textContent='YOUR ROLE';label.style.display='block';label.textContent='You are:';}
        else{rc.className='role-card crewmate';rt.textContent=my.word;title.textContent='YOUR WORD';label.style.display='none';}
        updateVotingUI(data);
        showScreen('multiGameScreen');
    }

    function updateVotingUI(data) {
        const c=document.getElementById('votePlayerList'); if(!c)return; c.innerHTML='';
        const players=data.players,votes=data.gameData.votes||{};
        const pids=Object.keys(players),total=pids.length;
        const vc={}; pids.forEach(id=>vc[id]=0);
        for(const[vid,vfor]of Object.entries(votes)){if(vfor&&vc.hasOwnProperty(vfor))vc[vfor]++;}
        const myVote=votes[playerId];
        for(const[id,p]of Object.entries(players)){
            const d=document.createElement('div'); d.className='vote-player-item'; if(id===playerId) d.classList.add('you');
            const info=document.createElement('div'); info.className='vote-player-info';
            const name=document.createElement('span'); name.className='vote-player-name'; name.textContent=p.name+(id===playerId?' (You)':''); info.appendChild(name);
            if(myVote===id){const lbl=document.createElement('span');lbl.className='your-vote-label';lbl.textContent='[your vote]';info.appendChild(lbl);}
            d.appendChild(info);
            const cnt=document.createElement('span');cnt.className='vote-count';cnt.textContent=vc[id];d.appendChild(cnt);
            if(id!==playerId){
                const btn=document.createElement('button');btn.className='vote-btn';
                if(myVote===id){btn.classList.add('voted');btn.textContent='VOTED';}else{btn.textContent='VOTE';}
                btn.onclick=()=>castVote(id);d.appendChild(btn);
            }
            c.appendChild(d);
        }
        const votedCnt=Object.values(votes).filter(v=>v!==null).length;
        document.getElementById('voteStatus').textContent=votedCnt+'/'+total+' voted';
        const maj=Math.floor(total/2)+1;
        for(const[id,cnt]of Object.entries(vc)){if(cnt>=maj&&isHost){roomRef.update({status:'results'});break;}}
    }

    async function castVote(tid) { if(!roomRef||!playerId)return; await roomRef.child('gameData/votes/'+playerId).set(tid); }

    function showMultiEndScreen(data) {
        const impId=data.gameData.imposterId;
        const impName=data.players[impId]?.name||'Unknown';
        const word=data.gameData.word;
        const votes=data.gameData.votes||{};
        const vc={}; Object.keys(data.players).forEach(id=>vc[id]=0);
        for(const[vid,vfor]of Object.entries(votes)){if(vfor&&vc.hasOwnProperty(vfor))vc[vfor]++;}
        let maxV=0,mostId=null;
        for(const[id,cnt]of Object.entries(vc)){if(cnt>maxV){maxV=cnt;mostId=id;}}
        const caught=mostId===impId;
        document.getElementById('resultName').textContent=impName;
        document.getElementById('resultWord').textContent='The word was: '+word;
        const rc=document.getElementById('resultCard'),rm=document.getElementById('resultMessage');
        if(caught){rc.className='result-card caught';rm.textContent='IMPOSTER CAUGHT!';}
        else{rc.className='result-card escaped';rm.textContent='IMPOSTER ESCAPED!';}
        const c=document.getElementById('endPlayerList');c.innerHTML='';
        for(const[id,p]of Object.entries(data.players)){
            const d=document.createElement('div');d.className='vote-player-item';
            if(id===impId)d.style.border='2px solid #ff0066';
            const info=document.createElement('div');info.className='vote-player-info';
            const name=document.createElement('span');name.className='vote-player-name';
            name.textContent=p.name+(id===impId?' [IMP]':'');info.appendChild(name);d.appendChild(info);
            const cnt=document.createElement('span');cnt.className='vote-count';cnt.textContent=vc[id]||0;d.appendChild(cnt);
            c.appendChild(d);
        }
        updateEndScreenButtons();
        showScreen('multiEndScreen');
    }

    function updateEndScreenButtons() {
        if(isHost){document.getElementById('newRoundBtn').style.display='block';document.getElementById('backToLobbyBtn').style.display='block';document.getElementById('leaveRoomEndBtn').style.display='none';document.getElementById('endStatus').style.display='none';}
        else{document.getElementById('newRoundBtn').style.display='none';document.getElementById('backToLobbyBtn').style.display='none';document.getElementById('leaveRoomEndBtn').style.display='block';document.getElementById('endStatus').style.display='block';}
    }

    async function newMultiRound() {
        if(!isHost)return;
        const snap=await roomRef.once('value');const data=snap.val();
        const pids=Object.keys(data.players);
        const impIdx=Math.floor(Math.random()*pids.length);
        const impId=pids[impIdx];
        const gw=data.words||multiModeWords;
        const word=getNextMultiWord(gw);
        const roles={},votes={};
        pids.forEach(id=>{roles[id]={isImposter:id===impId,word:id===impId?null:word};votes[id]=null;});
        await roomRef.update({gameData:{roles,word,imposterId:impId,votes},status:'playing'});
    }

    async function backToMultiLobby() { if(!isHost)return; await roomRef.update({gameData:null,status:'lobby'}); }

    function showMultiLobbyFromEnd(data) {
        document.getElementById('displayRoomCode').textContent=roomCode;
        if(isHost){document.getElementById('startGameBtn').style.display='block';document.getElementById('lobbyStatus').style.display='none';}
        else{document.getElementById('startGameBtn').style.display='none';document.getElementById('lobbyStatus').style.display='block';}
        initMultiWordEditor();
        showScreen('multiLobbyScreen');
    }

    async function leaveRoom() {
        if(roomRef&&playerId){
            roomRef.off();
            await roomRef.child('players/'+playerId).remove();
            if(isHost){
                const snap=await roomRef.child('players').once('value');
                const players=snap.val();
                if(players){const nid=Object.keys(players)[0];await roomRef.update({host:nid});await roomRef.child('players/'+nid+'/isHost').set(true);}
                else{await roomRef.remove();}
            }
        }
        playerId=null;roomCode=null;isHost=false;roomRef=null;
        multiModeWords=[...defaultWords];multiWordQueue=[];
        document.getElementById('menuError').textContent='';
        document.getElementById('playerName').value='';
        document.getElementById('joinCode').value='';
        showScreen('impModeScreen');
    }

    // ============================================================
    // BRASKET HANDOM: LOCAL
    // ============================================================
    let brLocalPlayers = 1;
    let brLocalSide = 'left';

    function brSetPlayerCount(n) {
        brLocalPlayers = n;
        document.getElementById('br1PBtn').classList.toggle('selected', n===1);
        document.getElementById('br2PBtn').classList.toggle('selected', n===2);
        // Show side select only for 1P
        document.getElementById('brSideSelect').style.display = n===1 ? 'flex' : 'none';
        document.getElementById('brSideLabel').style.display = n===1 ? 'block' : 'none';
    }

    function brSetSide(s) {
        brLocalSide = s;
        document.getElementById('brLeftBtn').classList.toggle('selected', s==='left');
        document.getElementById('brRightBtn').classList.toggle('selected', s==='right');
    }

    function startBrLocal() {
        document.getElementById('brIframe').src = 'https://2048taylorswift.github.io/basketrandom/';
        showScreen('brLocalGame');
    }

    function exitBrLocal() {
        document.getElementById('brIframe').src = '';
        showScreen('brLocalSetup');
    }

    // ============================================================
    // BRASKET HANDOM: ONLINE (Canvas game + Firebase)
    // ============================================================
    let brOnlineSide = 'left';
    let brOnlinePlayerId = null;
    let brOnlinePlayerName = '';
    let brOnlineRoomCode = null;
    let brOnlineIsHost = false;
    let brOnlineRoomRef = null;
    let brGameLoop = null;
    let brGameActive = false;

    // =============================================
    // BRASKET HANDOM - GAME ENGINE (Basket Random style)
    // =============================================
    const CW = 800, CH = 500;
    const GROUND_Y = CH - 45;
    const WIN_SCORE = 5;

    // Character dimensions (base)
    const CHAR_H = 70;       // total height
    const HEAD_R = 11;
    const TORSO_LEN = 22;
    const UPPER_LEG = 18;
    const LOWER_LEG = 16;
    const UPPER_ARM = 14;
    const LOWER_ARM = 12;
    const LIMB_W = 5;

    // Hoop positions
    const RIM_Y = 155;
    const RIM_LEFT_X = 78;
    const RIM_RIGHT_X = CW - 78;
    const RIM_W = 36; // rim opening width
    const BACKBOARD_H = 80;

    // Ball
    const BALL_R = 13;

    // Game state
    let gs = null;
    let brKeys = {};
    let brModTimer = 0;
    let brModName = '';
    let brModShowTimer = 0;
    let brScoreFlash = 0;
    let brGoalPause = 0;
    let brShake = 0;
    let brLastSyncTime = 0;
    let brFrameCount = 0;

    const MODIFIERS = [
        { name: 'MEGA BALL', apply: s => { s.mod.ballR = BALL_R * 2.2; } },
        { name: 'TINY BALL', apply: s => { s.mod.ballR = BALL_R * 0.6; } },
        { name: 'LOW GRAVITY', apply: s => { s.mod.grav = 0.18; } },
        { name: 'MOON GRAVITY', apply: s => { s.mod.grav = 0.1; } },
        { name: 'HEAVY GRAVITY', apply: s => { s.mod.grav = 0.7; } },
        { name: 'GIANT PLAYERS', apply: s => { s.mod.pScale = 1.5; } },
        { name: 'TINY PLAYERS', apply: s => { s.mod.pScale = 0.55; } },
        { name: 'ICE FLOOR', apply: s => { s.mod.friction = 0.995; } },
        { name: 'SUPER BOUNCY', apply: s => { s.mod.bounce = 0.92; } },
        { name: 'SPEED BOOST', apply: s => { s.mod.jumpPow = 16; } },
        { name: 'NORMAL', apply: s => { resetMod(s); } },
    ];

    function resetMod(s) {
        s.mod = { grav: 0.38, ballR: BALL_R, pScale: 1, bounce: 0.72, friction: 0.92, jumpPow: 12 };
    }

    function makePlayer(x, dir) {
        return {
            x: x, y: GROUND_Y,
            vx: 0, vy: 0,
            dir: dir,           // 1=faces right, -1=faces left
            bodyAngle: 0,       // torso tilt (radians)
            bodyAngVel: 0,
            kickTime: -1,       // -1=idle, 0+=kick phase (frames)
            legA1: 0, legA2: 0, // leg joint angles
            armA1: 0, armA2: 0, // arm joint angles
            grounded: true,
        };
    }

    function initGameState() {
        const s = {
            p: [ makePlayer(160, 1), makePlayer(CW - 160, -1) ],
            ball: { x: CW / 2, y: 250, vx: 0, vy: 0, spin: 0 },
            score: [0, 0],
            mod: {},
            inputs: [false, false],
            status: 'playing', // 'playing', 'goal', 'ended'
            winner: -1,
            goalTimer: 0,
            goalFor: -1,
            t: 0,
        };
        resetMod(s);
        return s;
    }

    function resetRound(s) {
        s.p[0] = makePlayer(160, 1);
        s.p[1] = makePlayer(CW - 160, -1);
        s.ball = { x: CW / 2, y: 220, vx: (Math.random() - 0.5) * 2, vy: -1, spin: 0 };
        s.inputs = [false, false];
        s.status = 'playing';
        s.goalTimer = 0;
        s.goalFor = -1;
    }

    // Get body part positions for a character (for collision + drawing)
    function getCharParts(p, sc) {
        const s = sc || 1;
        const hipX = p.x;
        const hipY = p.y;
        const ba = p.bodyAngle;
        const d = p.dir;

        // Torso goes upward from hip
        const shoulderX = hipX + Math.sin(ba) * TORSO_LEN * s;
        const shoulderY = hipY - Math.cos(ba) * TORSO_LEN * s;

        // Head
        const headX = shoulderX + Math.sin(ba) * (HEAD_R + 3) * s;
        const headY = shoulderY - Math.cos(ba) * (HEAD_R + 3) * s;

        // Left leg (kicking leg)
        const la1 = p.legA1;
        const kneeX = hipX + Math.cos(la1) * UPPER_LEG * s * d;
        const kneeY = hipY + Math.sin(la1) * UPPER_LEG * s;
        const la2 = p.legA2;
        const footX = kneeX + Math.cos(la2) * LOWER_LEG * s * d;
        const footY = kneeY + Math.sin(la2) * LOWER_LEG * s;

        // Right leg (support leg)
        const sla1 = Math.PI * 0.45; // hangs mostly down, slight back
        const skneeX = hipX - Math.cos(sla1) * UPPER_LEG * s * d * 0.3;
        const skneeY = hipY + Math.sin(sla1) * UPPER_LEG * s;
        const sfootX = skneeX - Math.cos(sla1) * LOWER_LEG * s * d * 0.1;
        const sfootY = skneeY + Math.sin(sla1) * LOWER_LEG * s;

        // Arms
        const aa1 = p.armA1;
        const elbowX = shoulderX + Math.cos(aa1) * UPPER_ARM * s * d;
        const elbowY = shoulderY + Math.sin(aa1) * UPPER_ARM * s;
        const aa2 = p.armA2;
        const handX = elbowX + Math.cos(aa2) * LOWER_ARM * s * d;
        const handY = elbowY + Math.sin(aa2) * LOWER_ARM * s;

        return {
            hipX, hipY, shoulderX, shoulderY, headX, headY, headR: HEAD_R * s,
            kneeX, kneeY, footX, footY,
            skneeX, skneeY, sfootX, sfootY,
            elbowX, elbowY, handX, handY,
        };
    }

    // Collision: circle vs line segment, returns push vector or null
    function circleSegDist(cx, cy, x1, y1, x2, y2) {
        const dx = x2 - x1, dy = y2 - y1;
        const len2 = dx * dx + dy * dy;
        if (len2 === 0) return Math.sqrt((cx - x1) ** 2 + (cy - y1) ** 2);
        let t = ((cx - x1) * dx + (cy - y1) * dy) / len2;
        t = Math.max(0, Math.min(1, t));
        const px = x1 + t * dx, py = y1 + t * dy;
        return Math.sqrt((cx - px) ** 2 + (cy - py) ** 2);
    }

    function updateGame(state) {
        if (state.status === 'ended') return;

        // Goal celebration pause
        if (state.status === 'goal') {
            state.goalTimer--;
            if (state.goalTimer <= 0) {
                // Apply random modifier for next round
                if (state.score[0] < WIN_SCORE && state.score[1] < WIN_SCORE) {
                    const mod = MODIFIERS[Math.floor(Math.random() * MODIFIERS.length)];
                    mod.apply(state);
                    brModName = mod.name;
                    brModShowTimer = 90;
                    resetRound(state);
                }
            }
            state.inputs = [false, false];
            return;
        }

        state.t++;
        const grav = state.mod.grav;
        const sc = state.mod.pScale;
        const br = state.mod.ballR;
        const bounce = state.mod.bounce;
        const fric = state.mod.friction;
        const jumpPow = state.mod.jumpPow;

        // ---- PLAYER PHYSICS ----
        for (let i = 0; i < 2; i++) {
            const p = state.p[i];

            // Input: jump + kick
            if (state.inputs[i] && p.grounded) {
                p.vy = -(jumpPow + Math.random() * 3);
                p.vx = p.dir * (3 + Math.random() * 4);
                p.grounded = false;
                p.kickTime = 0;
                p.bodyAngVel = -p.dir * (0.06 + Math.random() * 0.04);
            }

            // Kick animation
            if (p.kickTime >= 0) {
                p.kickTime++;
                const kt = p.kickTime;

                // Leg angles during kick (flying kick motion)
                if (kt < 8) {
                    // Wind up: legs pull back
                    p.legA1 = 0.4 + kt * 0.1;
                    p.legA2 = 0.6 + kt * 0.12;
                } else if (kt < 20) {
                    // Kick forward: legs extend
                    const t = (kt - 8) / 12;
                    p.legA1 = 0.4 + 0.8 - t * 1.8;
                    p.legA2 = 0.6 + 0.96 - t * 2.2;
                } else {
                    // Hold extended
                    p.legA1 = -0.6 + Math.sin(kt * 0.15) * 0.2;
                    p.legA2 = -0.64 + Math.sin(kt * 0.15 + 0.5) * 0.2;
                }

                // Arm flailing
                p.armA1 = Math.sin(kt * 0.25) * 1.5 - 0.5;
                p.armA2 = Math.sin(kt * 0.3 + 1) * 1.2;
            }

            // Gravity
            p.vy += grav;
            p.x += p.vx;
            p.y += p.vy;

            // Body tilt
            p.bodyAngle += p.bodyAngVel;
            if (p.grounded) {
                // Spring back to upright
                p.bodyAngle *= 0.85;
                p.bodyAngVel *= 0.8;
            }

            // Clamp body angle
            p.bodyAngle = Math.max(-1.2, Math.min(1.2, p.bodyAngle));

            // Ground collision
            if (p.y >= GROUND_Y) {
                p.y = GROUND_Y;
                p.vy = 0;
                p.vx *= fric;
                if (!p.grounded) {
                    // Landing
                    p.grounded = true;
                    p.kickTime = -1;
                    p.bodyAngVel = -p.bodyAngle * 0.3; // bounce back
                    // Reset limbs to idle
                    p.legA1 = 0.3 + Math.random() * 0.2;
                    p.legA2 = 0.4 + Math.random() * 0.2;
                    p.armA1 = 0.3;
                    p.armA2 = 0.5;
                }
                // Idle sway
                if (p.kickTime < 0) {
                    p.legA1 = 0.35 + Math.sin(state.t * 0.04) * 0.05;
                    p.legA2 = 0.45 + Math.sin(state.t * 0.04 + 0.3) * 0.05;
                    p.armA1 = 0.4 + Math.sin(state.t * 0.03) * 0.1;
                    p.armA2 = 0.6 + Math.sin(state.t * 0.035 + 0.5) * 0.1;
                }
            }

            // Wall clamp
            p.x = Math.max(30, Math.min(CW - 30, p.x));

            // Slow walk toward ball when grounded
            if (p.grounded && p.kickTime < 0) {
                const diff = state.ball.x - p.x;
                if (Math.abs(diff) > 40) {
                    p.vx += Math.sign(diff) * 0.15;
                }
                p.vx *= 0.9;
            }
        }

        // ---- BALL PHYSICS ----
        const b = state.ball;
        b.vy += grav;
        b.x += b.vx;
        b.y += b.vy;
        b.spin += b.vx * 0.04;

        // Ball-ground
        if (b.y + br >= GROUND_Y) {
            b.y = GROUND_Y - br;
            b.vy *= -bounce;
            b.vx *= 0.94;
            if (Math.abs(b.vy) < 1) b.vy = 0;
        }
        // Ball-ceiling
        if (b.y - br <= 0) { b.y = br; b.vy *= -bounce; }
        // Ball-walls
        if (b.x - br <= 0) { b.x = br; b.vx *= -0.6; }
        if (b.x + br >= CW) { b.x = CW - br; b.vx *= -0.6; }

        // Air drag
        b.vx *= 0.999;

        // ---- BALL vs PLAYER COLLISION ----
        for (let i = 0; i < 2; i++) {
            const p = state.p[i];
            const parts = getCharParts(p, sc);

            // Collider points: head, shoulder, hip, knee, foot, hand
            const colliders = [
                { x: parts.headX, y: parts.headY, r: parts.headR + 2, pow: 1.0 },
                { x: parts.shoulderX, y: parts.shoulderY, r: 8 * sc, pow: 0.8 },
                { x: parts.hipX, y: parts.hipY, r: 8 * sc, pow: 0.7 },
                { x: parts.kneeX, y: parts.kneeY, r: 7 * sc, pow: 1.2 },
                { x: parts.footX, y: parts.footY, r: 8 * sc, pow: 2.0 },
                { x: parts.handX, y: parts.handY, r: 6 * sc, pow: 1.0 },
                { x: parts.sfootX, y: parts.sfootY, r: 7 * sc, pow: 1.0 },
            ];

            for (const c of colliders) {
                const dx = b.x - c.x;
                const dy = b.y - c.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const minD = br + c.r;
                if (dist < minD && dist > 0.1) {
                    const nx = dx / dist, ny = dy / dist;
                    // Push ball out
                    b.x = c.x + nx * minD;
                    b.y = c.y + ny * minD;

                    // Hit force depends on body part power and velocity
                    const vel = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
                    const hitForce = (5 + vel * 0.6) * c.pow;
                    const kickBonus = (p.kickTime >= 8 && p.kickTime <= 25) ? 1.6 : 1.0;
                    b.vx = nx * hitForce * kickBonus + p.vx * 0.4 + (Math.random() - 0.5) * 2;
                    b.vy = ny * hitForce * kickBonus + p.vy * 0.3 - 2;

                    // Push player back
                    p.vx -= nx * 2;
                    p.vy -= ny * 1;
                    break; // only one collision per player per frame
                }
            }
        }

        // ---- BALL vs BACKBOARD / RIM ----
        // Left backboard (x=45, y from RIM_Y-40 to RIM_Y+30)
        if (b.x - br < 48 && b.y > RIM_Y - 40 && b.y < RIM_Y + 30 && b.vx < 0) {
            b.x = 48 + br; b.vx *= -0.5;
        }
        // Right backboard
        if (b.x + br > CW - 48 && b.y > RIM_Y - 40 && b.y < RIM_Y + 30 && b.vx > 0) {
            b.x = CW - 48 - br; b.vx *= -0.5;
        }
        // Left rim edges (two small circles at rim endpoints)
        rimBounce(b, br, bounce, RIM_LEFT_X - RIM_W / 2, RIM_Y);
        rimBounce(b, br, bounce, RIM_LEFT_X + RIM_W / 2, RIM_Y);
        // Right rim edges
        rimBounce(b, br, bounce, RIM_RIGHT_X - RIM_W / 2, RIM_Y);
        rimBounce(b, br, bounce, RIM_RIGHT_X + RIM_W / 2, RIM_Y);

        // ---- SCORING ----
        // Left hoop: ball center passes through rim opening going downward
        if (b.x > RIM_LEFT_X - RIM_W / 2 + 2 && b.x < RIM_LEFT_X + RIM_W / 2 - 2 &&
            b.y > RIM_Y && b.y < RIM_Y + 20 && b.vy > 0.5) {
            // Right player scores (scoring in opponent's hoop)
            scoreGoal(state, 1);
        }
        // Right hoop
        if (b.x > RIM_RIGHT_X - RIM_W / 2 + 2 && b.x < RIM_RIGHT_X + RIM_W / 2 - 2 &&
            b.y > RIM_Y && b.y < RIM_Y + 20 && b.vy > 0.5) {
            scoreGoal(state, 0);
        }

        // Clear inputs
        state.inputs = [false, false];
    }

    function rimBounce(b, br, bounce, rx, ry) {
        const rimR = 4;
        const dx = b.x - rx, dy = b.y - ry;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const minD = br + rimR;
        if (dist < minD && dist > 0.1) {
            const nx = dx / dist, ny = dy / dist;
            b.x = rx + nx * minD;
            b.y = ry + ny * minD;
            // Reflect velocity
            const dot = b.vx * nx + b.vy * ny;
            b.vx -= 2 * dot * nx * bounce;
            b.vy -= 2 * dot * ny * bounce;
            b.vx += (Math.random() - 0.5) * 1.5; // rattling randomness
        }
    }

    function scoreGoal(state, forPlayer) {
        state.score[forPlayer]++;
        state.goalFor = forPlayer;
        state.status = 'goal';
        state.goalTimer = 80; // ~1.3 seconds celebration
        brScoreFlash = 25;
        brShake = 12;
        if (state.score[forPlayer] >= WIN_SCORE) {
            state.status = 'ended';
            state.winner = forPlayer;
        }
    }

    // ---- RENDERING ----
    function renderGame(ctx, state) {
        const sc = state.mod.pScale;
        const br = state.mod.ballR;

        // Screen shake
        ctx.save();
        if (brShake > 0) {
            ctx.translate(
                (Math.random() - 0.5) * brShake * 1.5,
                (Math.random() - 0.5) * brShake * 1.5
            );
            brShake *= 0.88;
            if (brShake < 0.5) brShake = 0;
        }

        // Sky / background
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(0, 0, CW, CH);

        // Court floor (wood)
        const floorGrad = ctx.createLinearGradient(0, GROUND_Y, 0, CH);
        floorGrad.addColorStop(0, '#8B5E3C');
        floorGrad.addColorStop(1, '#6B3F1F');
        ctx.fillStyle = floorGrad;
        ctx.fillRect(0, GROUND_Y, CW, CH - GROUND_Y);

        // Floor lines
        ctx.strokeStyle = '#9B6E4C';
        ctx.lineWidth = 1;
        for (let lx = 0; lx < CW; lx += 60) {
            ctx.beginPath(); ctx.moveTo(lx, GROUND_Y); ctx.lineTo(lx, CH); ctx.stroke();
        }
        ctx.strokeStyle = '#A0784F';
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(0, GROUND_Y); ctx.lineTo(CW, GROUND_Y); ctx.stroke();

        // Center line
        ctx.strokeStyle = 'rgba(255,255,255,0.1)';
        ctx.lineWidth = 2;
        ctx.setLineDash([6, 6]);
        ctx.beginPath(); ctx.moveTo(CW / 2, GROUND_Y - 5); ctx.lineTo(CW / 2, GROUND_Y + 50); ctx.stroke();
        ctx.setLineDash([]);

        // Center circle
        ctx.strokeStyle = 'rgba(255,255,255,0.08)';
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(CW / 2, GROUND_Y, 50, Math.PI, 0); ctx.stroke();

        // Draw hoops (behind players)
        drawHoop(ctx, RIM_LEFT_X, RIM_Y, true);
        drawHoop(ctx, RIM_RIGHT_X, RIM_Y, false);

        // Draw players
        drawChar(ctx, state.p[0], sc, '#00BFFF', '#0088BB', '#FFD93D');
        drawChar(ctx, state.p[1], sc, '#FF6B2B', '#CC4400', '#FFD93D');

        // Draw ball
        drawBall(ctx, state.ball, br);

        // Score flash overlay
        if (brScoreFlash > 0) {
            ctx.fillStyle = `rgba(255,255,255,${brScoreFlash / 50})`;
            ctx.fillRect(0, 0, CW, CH);
            brScoreFlash--;
        }

        // Goal text
        if (state.status === 'goal') {
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 36px "Press Start 2P", monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = state.goalFor === 0 ? '#00BFFF' : '#FF6B2B';
            ctx.shadowBlur = 30;
            ctx.fillText('SCORE!', CW / 2, CH / 2 - 20);
            ctx.shadowBlur = 0;
        }

        // In-canvas score
        ctx.font = 'bold 22px "Press Start 2P", monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.fillStyle = '#00BFFF';
        ctx.fillText(state.score[0], CW / 2 - 50, 15);
        ctx.fillStyle = '#444';
        ctx.fillText(':', CW / 2, 15);
        ctx.fillStyle = '#FF6B2B';
        ctx.fillText(state.score[1], CW / 2 + 50, 15);

        ctx.restore();
    }

    function drawHoop(ctx, rx, ry, isLeft) {
        const dir = isLeft ? -1 : 1;
        const bbX = isLeft ? 40 : CW - 40;

        // Pole
        ctx.strokeStyle = '#555';
        ctx.lineWidth = 5;
        ctx.beginPath();
        ctx.moveTo(bbX, GROUND_Y);
        ctx.lineTo(bbX, ry - 42);
        ctx.stroke();

        // Backboard
        ctx.fillStyle = '#ddd';
        ctx.fillRect(bbX - 3, ry - 42, 6, BACKBOARD_H);
        ctx.strokeStyle = '#888';
        ctx.lineWidth = 1;
        ctx.strokeRect(bbX - 3, ry - 42, 6, BACKBOARD_H);

        // Backboard inner rectangle (target square)
        ctx.strokeStyle = '#ff4444';
        ctx.lineWidth = 1.5;
        ctx.strokeRect(bbX + dir * 2 - 1, ry - 14, 3, 24);

        // Rim bracket
        ctx.fillStyle = '#ff4411';
        ctx.fillRect(bbX + dir * 2, ry - 3, dir * (RIM_W / 2 + 8), 5);

        // Rim (the scoring opening)
        ctx.strokeStyle = '#ff4411';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(rx - RIM_W / 2, ry);
        ctx.lineTo(rx + RIM_W / 2, ry);
        ctx.stroke();

        // Rim endpoints (small circles for visual)
        ctx.fillStyle = '#ff4411';
        ctx.beginPath(); ctx.arc(rx - RIM_W / 2, ry, 3, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(rx + RIM_W / 2, ry, 3, 0, Math.PI * 2); ctx.fill();

        // Net
        ctx.strokeStyle = 'rgba(255,255,255,0.35)';
        ctx.lineWidth = 1.2;
        const netH = 28;
        const netSegs = 5;
        for (let i = 0; i <= netSegs; i++) {
            const t = i / netSegs;
            const topX = rx - RIM_W / 2 + t * RIM_W;
            const bottomX = rx - RIM_W / 4 + t * RIM_W / 2;
            ctx.beginPath();
            ctx.moveTo(topX, ry + 2);
            // Slight curve
            ctx.quadraticCurveTo(
                (topX + bottomX) / 2 + Math.sin(t * 3 + brFrameCount * 0.02) * 3,
                ry + netH * 0.6,
                bottomX, ry + netH
            );
            ctx.stroke();
        }
        // Horizontal net lines
        for (let j = 1; j <= 3; j++) {
            const ny = ry + 2 + (netH * j) / 4;
            const shrink = j * 2;
            ctx.beginPath();
            ctx.moveTo(rx - RIM_W / 2 + shrink, ny);
            ctx.lineTo(rx + RIM_W / 2 - shrink, ny);
            ctx.stroke();
        }
    }

    function drawChar(ctx, p, sc, color, darkColor, skinColor) {
        const parts = getCharParts(p, sc);

        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        // Support leg
        ctx.strokeStyle = darkColor;
        ctx.lineWidth = LIMB_W * sc;
        ctx.beginPath();
        ctx.moveTo(parts.hipX, parts.hipY);
        ctx.lineTo(parts.skneeX, parts.skneeY);
        ctx.lineTo(parts.sfootX, parts.sfootY);
        ctx.stroke();
        // Shoe
        ctx.fillStyle = '#333';
        ctx.beginPath(); ctx.arc(parts.sfootX, parts.sfootY, 4 * sc, 0, Math.PI * 2); ctx.fill();

        // Kicking leg
        ctx.strokeStyle = color;
        ctx.lineWidth = (LIMB_W + 1) * sc;
        ctx.beginPath();
        ctx.moveTo(parts.hipX, parts.hipY);
        ctx.lineTo(parts.kneeX, parts.kneeY);
        ctx.lineTo(parts.footX, parts.footY);
        ctx.stroke();
        // Shoe
        ctx.fillStyle = '#222';
        ctx.beginPath(); ctx.arc(parts.footX, parts.footY, 5 * sc, 0, Math.PI * 2); ctx.fill();

        // Torso
        ctx.strokeStyle = color;
        ctx.lineWidth = (LIMB_W + 3) * sc;
        ctx.beginPath();
        ctx.moveTo(parts.hipX, parts.hipY);
        ctx.lineTo(parts.shoulderX, parts.shoulderY);
        ctx.stroke();

        // Jersey stripe
        const mx = (parts.hipX + parts.shoulderX) / 2;
        const my = (parts.hipY + parts.shoulderY) / 2;
        ctx.strokeStyle = darkColor;
        ctx.lineWidth = 3 * sc;
        ctx.beginPath();
        ctx.moveTo(mx - 4 * sc * p.dir, my);
        ctx.lineTo(mx + 4 * sc * p.dir, my);
        ctx.stroke();

        // Arm
        ctx.strokeStyle = skinColor;
        ctx.lineWidth = (LIMB_W - 1) * sc;
        ctx.beginPath();
        ctx.moveTo(parts.shoulderX, parts.shoulderY);
        ctx.lineTo(parts.elbowX, parts.elbowY);
        ctx.lineTo(parts.handX, parts.handY);
        ctx.stroke();
        // Hand
        ctx.fillStyle = skinColor;
        ctx.beginPath(); ctx.arc(parts.handX, parts.handY, 3 * sc, 0, Math.PI * 2); ctx.fill();

        // Head
        ctx.fillStyle = skinColor;
        ctx.beginPath();
        ctx.arc(parts.headX, parts.headY, parts.headR, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#CC9900';
        ctx.lineWidth = 1.5;
        ctx.stroke();

        // Eyes (always facing direction)
        const eyeOff = p.dir * 3 * sc;
        ctx.fillStyle = '#222';
        ctx.beginPath();
        ctx.arc(parts.headX + eyeOff, parts.headY - 2 * sc, 2 * sc, 0, Math.PI * 2);
        ctx.fill();
        // Eye white dot
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(parts.headX + eyeOff + 0.5 * sc, parts.headY - 2.5 * sc, 0.8 * sc, 0, Math.PI * 2);
        ctx.fill();

        // Headband
        ctx.strokeStyle = color;
        ctx.lineWidth = 3 * sc;
        const hbAngle = p.bodyAngle;
        ctx.beginPath();
        ctx.arc(parts.headX, parts.headY, parts.headR + 1, -Math.PI * 0.3 + hbAngle, Math.PI * 0.3 + hbAngle);
        ctx.stroke();
    }

    function drawBall(ctx, ball, br) {
        ctx.save();
        ctx.translate(ball.x, ball.y);
        ctx.rotate(ball.spin);

        // Ball shadow
        ctx.fillStyle = 'rgba(0,0,0,0.15)';
        ctx.beginPath();
        ctx.ellipse(2, 2, br, br * 0.9, 0, 0, Math.PI * 2);
        ctx.fill();

        // Ball body
        const grad = ctx.createRadialGradient(-br * 0.3, -br * 0.3, br * 0.1, 0, 0, br);
        grad.addColorStop(0, '#FF8C00');
        grad.addColorStop(0.7, '#E06000');
        grad.addColorStop(1, '#B84000');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(0, 0, br, 0, Math.PI * 2);
        ctx.fill();

        // Ball outline
        ctx.strokeStyle = '#8B3000';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.arc(0, 0, br, 0, Math.PI * 2);
        ctx.stroke();

        // Seam lines
        ctx.strokeStyle = '#8B300066';
        ctx.lineWidth = 1;
        // Vertical
        ctx.beginPath();
        ctx.ellipse(0, 0, br * 0.15, br, 0, 0, Math.PI * 2);
        ctx.stroke();
        // Horizontal
        ctx.beginPath();
        ctx.moveTo(-br * 0.7, 0);
        ctx.quadraticCurveTo(0, -br * 0.3, br * 0.7, 0);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(-br * 0.7, 0);
        ctx.quadraticCurveTo(0, br * 0.3, br * 0.7, 0);
        ctx.stroke();

        ctx.restore();
    }

    // Side selection
    function brOnlineSetSide(s) {
        brOnlineSide = s;
        document.getElementById('brOnLeftBtn').classList.toggle('selected', s === 'left');
        document.getElementById('brOnRightBtn').classList.toggle('selected', s === 'right');
    }

    // Create room
    async function brCreateRoom() {
        brOnlinePlayerName = document.getElementById('brPlayerName').value.trim();
        if (!brOnlinePlayerName) { document.getElementById('brMenuError').textContent = 'Enter your name!'; return; }

        brOnlinePlayerId = generatePlayerId();
        brOnlineRoomCode = generateRoomCode();
        brOnlineIsHost = true;

        brOnlineRoomRef = db.ref('brRooms/' + brOnlineRoomCode);
        const snap = await brOnlineRoomRef.once('value');
        if (snap.exists()) { brOnlineRoomCode = generateRoomCode(); brOnlineRoomRef = db.ref('brRooms/' + brOnlineRoomCode); }

        await brOnlineRoomRef.set({
            host: brOnlinePlayerId,
            status: 'lobby',
            players: { [brOnlinePlayerId]: { name: brOnlinePlayerName, side: brOnlineSide } },
            gameState: null,
            createdAt: firebase.database.ServerValue.TIMESTAMP
        });

        brOnlineRoomRef.child('players/' + brOnlinePlayerId).onDisconnect().remove();
        setupBrRoomListeners();

        document.getElementById('brDisplayRoomCode').textContent = brOnlineRoomCode;
        document.getElementById('brStartBtn').style.display = 'block';
        document.getElementById('brLobbyStatus').textContent = 'Waiting for opponent...';

        showScreen('brOnlineLobby');
    }

    // Join room
    async function brJoinRoom() {
        brOnlinePlayerName = document.getElementById('brPlayerName').value.trim();
        const code = document.getElementById('brJoinCode').value.trim().toUpperCase();
        if (!brOnlinePlayerName) { document.getElementById('brMenuError').textContent = 'Enter your name!'; return; }
        if (!code || code.length !== 4) { document.getElementById('brMenuError').textContent = 'Enter a valid 4-letter code!'; return; }

        brOnlineRoomRef = db.ref('brRooms/' + code);
        const snap = await brOnlineRoomRef.once('value');
        if (!snap.exists()) { document.getElementById('brMenuError').textContent = 'Room not found!'; return; }

        const rd = snap.val();
        if (rd.status !== 'lobby') { document.getElementById('brMenuError').textContent = 'Game already started!'; return; }

        const existingPlayers = Object.values(rd.players || {});
        if (existingPlayers.length >= 2) { document.getElementById('brMenuError').textContent = 'Room is full!'; return; }

        // Auto-assign opposite side if same side chosen
        const hostSide = existingPlayers[0]?.side || 'left';
        if (brOnlineSide === hostSide) {
            brOnlineSide = hostSide === 'left' ? 'right' : 'left';
            brOnlineSetSide(brOnlineSide);
        }

        brOnlinePlayerId = generatePlayerId();
        brOnlineRoomCode = code;
        brOnlineIsHost = false;

        await brOnlineRoomRef.child('players/' + brOnlinePlayerId).set({ name: brOnlinePlayerName, side: brOnlineSide });
        brOnlineRoomRef.child('players/' + brOnlinePlayerId).onDisconnect().remove();
        setupBrRoomListeners();

        document.getElementById('brDisplayRoomCode').textContent = brOnlineRoomCode;
        document.getElementById('brStartBtn').style.display = 'none';
        document.getElementById('brLobbyStatus').textContent = 'Waiting for host to start...';

        showScreen('brOnlineLobby');
    }

    function setupBrRoomListeners() {
        brOnlineRoomRef.on('value', (snap) => {
            if (!snap.exists()) {
                brCleanup();
                alert('Room closed!');
                showScreen('brOnlineMenu');
                return;
            }

            const data = snap.val();
            if (data.host === brOnlinePlayerId) brOnlineIsHost = true;

            // Update lobby player list
            const plc = document.getElementById('brPlayerListContainer');
            if (plc && data.players) {
                plc.innerHTML = '';
                for (const [id, p] of Object.entries(data.players)) {
                    const d = document.createElement('div');
                    d.className = 'player-item';
                    if (id === brOnlinePlayerId) d.classList.add('you');
                    d.textContent = p.name + ' (' + p.side.toUpperCase() + ')' + (id === brOnlinePlayerId ? ' - You' : '');
                    plc.appendChild(d);
                }

                const cnt = Object.keys(data.players).length;
                if (brOnlineIsHost) {
                    document.getElementById('brStartBtn').style.display = 'block';
                    document.getElementById('brStartBtn').disabled = cnt < 2;
                    document.getElementById('brStartBtn').textContent = cnt < 2 ? 'NEED 2 PLAYERS' : 'START';
                }
            }

            // Game started
            if (data.status === 'playing' && (currentScreen === 'brOnlineLobby' || currentScreen === 'brOnlineEnd')) {
                brStartGameplay(data);
            }

            // Sync game state (client only) - handle playing and goal states
            if ((data.status === 'playing') && currentScreen === 'brOnlineGame' && !brOnlineIsHost && data.gameState) {
                const newGs = JSON.parse(JSON.stringify(data.gameState));
                // Detect score changes for flash/shake effects
                if (gs && newGs.score && gs.score &&
                    (newGs.score[0] !== gs.score[0] || newGs.score[1] !== gs.score[1])) {
                    brScoreFlash = 25;
                    brShake = 12;
                }
                gs = newGs;
                updateBrScoreUI();
                if (gs.status === 'ended') {
                    brShowEndScreen();
                }
            }

            // Game ended
            if (data.status === 'ended' && currentScreen === 'brOnlineGame') {
                if (data.gameState) gs = JSON.parse(JSON.stringify(data.gameState));
                brShowEndScreen();
            }

            // Back to lobby
            if (data.status === 'lobby' && (currentScreen === 'brOnlineEnd' || currentScreen === 'brOnlineGame')) {
                brStopGameLoop();
                showScreen('brOnlineLobby');
            }
        });
    }

    // Get my player index (0=left, 1=right)
    function getMyPlayerIndex() {
        return brOnlineSide === 'left' ? 0 : 1;
    }

    async function brStartOnlineGame() {
        if (!brOnlineIsHost) return;
        const snap = await brOnlineRoomRef.once('value');
        const data = snap.val();
        if (Object.keys(data.players || {}).length < 2) return;

        gs = initGameState();
        brModTimer = 0;

        await brOnlineRoomRef.update({
            gameState: gs,
            status: 'playing'
        });
    }

    function brStartGameplay(data) {
        if (data.gameState) gs = JSON.parse(JSON.stringify(data.gameState));
        else gs = initGameState();

        brModTimer = 0;
        brScoreFlash = 0;
        brGameActive = true;

        showScreen('brOnlineGame');
        updateBrScoreUI();

        if (brOnlineIsHost) {
            brStartGameLoop();
        } else {
            brStartRenderLoop();
        }
    }

    function brStartGameLoop() {
        const canvas = document.getElementById('brCanvas');
        const ctx = canvas.getContext('2d');

        brStopGameLoop();
        brGameActive = true;
        brFrameCount = 0;

        function loop() {
            if (!brGameActive) return;
            brFrameCount++;
            const now = performance.now();

            if (brModShowTimer > 0) brModShowTimer--;

            updateGame(gs);
            renderGame(ctx, gs);

            // Show modifier name
            const announce = document.getElementById('brModAnnounce');
            if (brModShowTimer > 0) {
                announce.textContent = brModName;
                announce.classList.add('show');
            } else {
                announce.classList.remove('show');
            }

            updateBrScoreUI();

            // Sync to Firebase at ~15fps
            if (now - brLastSyncTime > 66) {
                brLastSyncTime = now;
                if (brOnlineRoomRef) {
                    brOnlineRoomRef.child('gameState').set(gs);
                }
            }

            // Check win
            if (gs.status === 'ended') {
                brOnlineRoomRef.update({ gameState: gs, status: 'ended' });
                brShowEndScreen();
                return;
            }

            brGameLoop = requestAnimationFrame(loop);
        }

        brGameLoop = requestAnimationFrame(loop);
    }

    function brStartRenderLoop() {
        const canvas = document.getElementById('brCanvas');
        const ctx = canvas.getContext('2d');

        brStopGameLoop();
        brGameActive = true;

        function loop() {
            if (!brGameActive) return;
            brFrameCount++;
            if (gs) {
                renderGame(ctx, gs);
            }

            const announce = document.getElementById('brModAnnounce');
            if (brModShowTimer > 0) {
                announce.textContent = brModName;
                announce.classList.add('show');
                brModShowTimer--;
            } else {
                announce.classList.remove('show');
            }

            brGameLoop = requestAnimationFrame(loop);
        }

        brGameLoop = requestAnimationFrame(loop);
    }

    function brStopGameLoop() {
        if (brGameLoop) {
            cancelAnimationFrame(brGameLoop);
            brGameLoop = null;
        }
        brGameActive = false;
    }

    function updateBrScoreUI() {
        if (!gs) return;
        document.getElementById('brScoreLeft').textContent = gs.score[0];
        document.getElementById('brScoreRight').textContent = gs.score[1];
    }

    function brShowEndScreen() {
        brStopGameLoop();

        document.getElementById('brEndScoreLeft').textContent = gs.score[0];
        document.getElementById('brEndScoreRight').textContent = gs.score[1];

        const myIdx = getMyPlayerIndex();
        let msg = '';
        if (gs.winner === myIdx) msg = 'YOU WIN!';
        else if (gs.winner === -1) msg = 'DRAW!';
        else msg = 'YOU LOSE!';
        document.getElementById('brEndMessage').textContent = msg;

        if (brOnlineIsHost) {
            document.getElementById('brPlayAgainBtn').style.display = 'block';
            document.getElementById('brEndStatus').style.display = 'none';
        } else {
            document.getElementById('brPlayAgainBtn').style.display = 'none';
            document.getElementById('brEndStatus').style.display = 'block';
        }

        showScreen('brOnlineEnd');
    }

    async function brPlayAgain() {
        if (!brOnlineIsHost || !brOnlineRoomRef) return;
        gs = initGameState();
        brModTimer = 0;
        await brOnlineRoomRef.update({ gameState: gs, status: 'playing' });
    }

    function brCleanup() {
        brStopGameLoop();
        if (brOnlineRoomRef) brOnlineRoomRef.off();
        brOnlineRoomRef = null;
        brOnlinePlayerId = null;
        brOnlineRoomCode = null;
        brOnlineIsHost = false;
        gs = null;
    }

    async function brLeaveRoom() {
        if (brOnlineRoomRef && brOnlinePlayerId) {
            brOnlineRoomRef.off();
            await brOnlineRoomRef.child('players/' + brOnlinePlayerId).remove();
            if (brOnlineIsHost) {
                const snap = await brOnlineRoomRef.child('players').once('value');
                const players = snap.val();
                if (players) {
                    const nid = Object.keys(players)[0];
                    await brOnlineRoomRef.update({ host: nid });
                } else {
                    await brOnlineRoomRef.remove();
                }
            }
        }
        brCleanup();
        document.getElementById('brMenuError').textContent = '';
        document.getElementById('brPlayerName').value = '';
        document.getElementById('brJoinCode').value = '';
        showScreen('brModeScreen');
    }

    function brLeaveOnlineGame() {
        brLeaveRoom();
    }

    // ============================================================
    // INPUT HANDLING
    // ============================================================
    document.addEventListener('keydown', (e) => {
        if (!brGameActive || !gs || gs.status !== 'playing') return;

        const myIdx = getMyPlayerIndex();
        const key = e.key.toLowerCase();

        if (key === ' ' || key === 'w' || key === 'arrowup') {
            e.preventDefault();
            if (brOnlineIsHost) {
                // Host: apply input directly
                gs.inputs[myIdx] = true;
            } else {
                // Client: send input to Firebase
                if (brOnlineRoomRef) {
                    brOnlineRoomRef.child('gameState/inputs/' + myIdx).set(true);
                }
            }
        }
    });

    // Host listens for client inputs
    function setupInputListener() {
        if (brOnlineRoomRef && brOnlineIsHost) {
            const opponentIdx = getMyPlayerIndex() === 0 ? 1 : 0;
            brOnlineRoomRef.child('gameState/inputs/' + opponentIdx).on('value', (snap) => {
                if (snap.val() === true && gs && gs.status === 'playing') {
                    gs.inputs[opponentIdx] = true;
                }
            });
        }
    }

    // Override brStartOnlineGame to add input listener
    const _origBrStart = brStartOnlineGame;
    brStartOnlineGame = async function() {
        await _origBrStart();
        setupInputListener();
    };

    // Also set up input listener when game starts for host via room listener
    const _origBrStartGameplay = brStartGameplay;
    brStartGameplay = function(data) {
        _origBrStartGameplay(data);
        if (brOnlineIsHost) setupInputListener();
    };

    // ============================================================
    // INIT
    // ============================================================
    document.getElementById('joinCode').addEventListener('input', function() { this.value = this.value.toUpperCase(); });
    document.getElementById('brJoinCode').addEventListener('input', function() { this.value = this.value.toUpperCase(); });

    document.addEventListener('DOMContentLoaded', () => {
        document.getElementById('singleWordTextarea').addEventListener('input', updateSingleWordCount);
        document.getElementById('multiWordTextarea').addEventListener('input', updateMultiWordCount);
    });
    </script>
</body>
</html>
